# Advent of Code 2022 with Lua 5.4

I wanted to do this year's AoC using Lua to get some experience with it, since it is embedded in and used to configure a whole bunch of programs, of which [neovim](https://neovim.io/) is the most important for me. 

It was a fun and very simple language to learn, but not very suited to AoC. I'll compile my thoughts about it after AoC ends.

I usually tried to make my solutions _fast_ (< 50ms), even though I'm running the code on the relatively new [Lua 5.4](https://www.lua.org/manual/5.4/manual.html) interpreter and not using the legendary [LuaJIT](https://luajit.org/luajit.html). Speed usually happens coincidentally since most problems are straightforward, but some days did require me to modify my initial straightforward approaches. I compiled some notes about those below. 

## howtospeed

### Day 11

The straightforward implementation of this one in which every monkey had a list of items took around 120ms for the 10,000 steps in part 2.

To make this a bit faster, I flipped the representation: All the items are held together in a global list. For each item, I run a big loop that applies each operation and moves the item through the monkey graph, tracking which monkey it belongs to with a single integer. The round count is increased every time the item has to move backwards in monkey indices. This speeds up execution because we don't keep moving items around different arrays; each item completes all 10,000 without moving _at all_. 

This still feels relatively slow though!

### Day 12

For part 2, instead of running a BFS starting from each `a` and taking their minimum, it is more efficient to run a single exhaustive BFS in reverse starting from E recording the minimum distance to each cell. Blazing!

### Day 14

After going through some less inspired approaches, I ended up using a simple "drop 1 grain at a time" approach, which took around 230ms. Speeding this up is not too hard, because making the next sand grain start from scratch every time is wasteful. Instead, we can put the next sand grain at the position the last sand grain was at just before coming to a rest and move from there. Keeping a stack of previous positions and popping from it to get the initial position of the next sand grain does the trick!

## Automated Tests

These are generated by `test_solutions` and appended to `readme_template.md` to complete the README, and times are reported by `time -p`. They are meant to give a rough idea of the execution time on my machine and are not very precise. 

A pre-commit [hook](https://githooks.com/) `test_hook` runs automatically after every commit and refreshes the below table. In case a test fails, the commit is aborted and I get to fix the code. Otherwise, the updated README gets staged and the commit completed.

To set up this hook after cloning the repository, you just have to link it:
```
ln test_hook .git/hooks/pre-commit
```

### ... and their results

```diff
+ day1	part1: OK (0.00s)
+ day1	part2: OK (0.00s)
+ day2	part1: OK (0.00s)
+ day2	part2: OK (0.00s)
+ day3	part1: OK (0.00s)
+ day3	part2: OK (0.00s)
+ day4	part1: OK (0.00s)
+ day4	part2: OK (0.00s)
+ day5	part1: OK (0.00s)
+ day5	part2: OK (0.00s)
+ day6	part1: OK (0.00s)
+ day6	part2: OK (0.00s)
+ day7	part1: OK (0.00s)
+ day7	part2: OK (0.00s)
+ day8	part1: OK (0.01s)
+ day8	part2: OK (0.01s)
+ day9	part1: OK (0.00s)
+ day9	part2: OK (0.02s)
+ day10	part1: OK (0.00s)
+ day10	part2: OK (0.00s)
+ day11	part1: OK (0.00s)
+ day11	part2: OK (0.04s)
+ day12	part1: OK (0.00s)
+ day12	part2: OK (0.00s)
+ day13	part1: OK (0.00s)
+ day13	part2: OK (0.00s)
+ day14	part1: OK (0.00s)
+ day14	part2: OK (0.01s)
+ day15	part1: OK (0.00s)
+ day15	part2: OK (18.20s)
```
